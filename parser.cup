/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import java.util.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.io.*; 

parser code {:
  protected Lexer lexer;
  public static int errors = 0;

  public void report_error(String message, Object info){
    if (info instanceof String){
	errors++; 
      System.err.println("  "+ errors + "==> " + info + " "+ message +
							"near " + lexer.current_lexeme());
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }

:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, DIVIDE, TIMES, LPAREN, RPAREN, MOD;
terminal Integer    INTEGER_LITERAL;        // our scanner provides numbers as integersterminal			VAR;4
terminal Float		FLOAT_LITERAL;
terminal Boolean    BOOLEAN_LITERAL;
terminal			VAR, COLON, COMMA, CONST;
terminal            GT, LT, LE, GE, DIFF, NOT, AND, OR, XOR;
terminal			BOOL, INT, CHAR;
terminal			EQUAL, FULLSTOP;
terminal String     IDENTIFIER;
terminal			NEWLINE, PROGRAM, BEGIN, END, PROCEDURE, FUNCTION;
terminal            FOR, TO, DOWNTO, DO;

/* Non terminals */
non terminal              initial, program_def_part, body_def_part, program_def, header_declarations;
non terminal			  function_def_part, function_body, function_declaration; 
non terminal              procedure_def_part, procedure_declaration, procedure_body;
non terminal              parameter, parameters, parameters_list;
non terminal 			  block, block_end;
non terminal              stmt_def_part, stmt_def_list, stmt;
non terminal              exp_list, literal;
non terminal 		      exp, rel_op, bool_op, log_op, bin_arim_op, un_arim_op;
non terminal			  exp_part;
non terminal			  variable_def, variable_def_list, variable_def_part, variable_opt_nl;
non terminal              const_def, const_def_list, const_def_part;
non terminal List<String> identifier_list;
non terminal String   	  identifier;
non terminal			  type_def, for_direction, for_def_part, for_def, control_attr;
non terminal		      attr, assign_operator, equal_op, sum_op, minus_op, times_op, divide_op;
/* Precedences */ 
precedence nonassoc VAR;	// Inserted by Eclipse plugin
precedence nonassoc PROCEDURE;	// Inserted by Eclipse plugin
precedence nonassoc FUNCTION;	// Inserted by Eclipse plugin
precedence nonassoc error;	// Inserted by Eclipse plugin
precedence nonassoc SEMI;	// Inserted by Eclipse plugin
precedence nonassoc MOD;	// Inserted by Eclipse plugin
precedence nonassoc XOR;	// Inserted by Eclipse plugin
precedence nonassoc OR;	// Inserted by Eclipse plugin
precedence nonassoc AND;	// Inserted by Eclipse plugin
precedence nonassoc DIFF;	// Inserted by Eclipse plugin
precedence nonassoc GE;	// Inserted by Eclipse plugin
precedence nonassoc LE;	// Inserted by Eclipse plugin
precedence nonassoc LE;	// Inserted by Eclipse plugin
precedence nonassoc LT;	// Inserted by Eclipse plugin
precedence nonassoc GT;	// Inserted by Eclipse plugin
precedence nonassoc NEWLINE;	// Inserted by Eclipse plugin
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left DIVIDE;

start with initial;
/* The grammar rules */

initial ::= program_def_part program_def;
program_def ::= variable_def_part header_declarations body_def_part;
program_def ::= header_declarations variable_def_part body_def_part;

program_def_part ::= PROGRAM identifier SEMI;

body_def_part ::= BEGIN stmt_def_part END FULLSTOP;
body_def_part ::= stmt_def_part END FULLSTOP;

stmt_def_part ::= stmt_def_list | ;
stmt_def_list ::= stmt_def_list stmt;
stmt_def_list ::= stmt;
stmt_def_list ::= NEWLINE stmt_def_list;
stmt ::= attr;

for_def_part ::= FOR ;
for_def_part ::= error {: parser.report_error("Invalid loop syntax ", "ERROR"); :} ;
for_def ::= control_attr ;
for_direction ::= TO;
for_direction ::= DOWNTO;

control_attr ::= identifier COLON EQUAL exp;

const_def_part ::= CONST const_def_list;
const_def_list ::= const_def_list const_def; 
const_def_list ::= const_def;
const_def ::= identifier_list COLON type_def EQUAL exp_part;

identifier ::= IDENTIFIER:x;

header_declarations ::= procedure_def_part | function_def_part;


block ::= BEGIN;
block_end ::= END SEMI;


procedure_def_part ::= procedure_declaration  procedure_body;
procedure_declaration ::= PROCEDURE identifier parameters_list SEMI;
procedure_body ::= block stmt_def_part block_end;


function_def_part ::= function_declaration function_body;
function_declaration ::= FUNCTION identifier parameters_list COLON type_def SEMI;
function_body ::= block stmt_def_part block_end;

parameters_list ::= LPAREN parameters RPAREN;
parameter ::= identifier_list COLON type_def;
parameters ::= parameter SEMI parameters;
parameters ::= parameter;


exp_list ::= exp_part ; 
exp_part ::= exp SEMI;
exp ::= exp error {: parser.report_error("Missing operand ", "ERROR"); :};
exp ::= bool_op exp;
exp ::= exp log_op exp;
exp ::= un_arim_op exp;
exp ::= exp bin_arim_op exp;
exp ::= exp rel_op exp;
exp ::= LPAREN exp RPAREN;
exp ::= literal;
exp ::= identifier;
//exp_list ::= error {: parser.report_fatal_error("O caraio", "ERROR"); :};

literal ::= INTEGER_LITERAL;
literal ::= FLOAT_LITERAL;
literal ::= BOOLEAN_LITERAL;

rel_op ::= GT;
rel_op ::= LT;
rel_op ::= GE;
rel_op ::= LE;
rel_op ::= DIFF;
//rel_op ::= error  {: parser.repoer:};

bool_op ::= NOT;

log_op ::= AND;
log_op ::= XOR;
log_op ::= OR;

bin_arim_op ::= PLUS;
bin_arim_op ::= MINUS;
bin_arim_op ::= TIMES;
bin_arim_op ::= DIVIDE;
bin_arim_op ::= MOD;

un_arim_op ::= PLUS;
un_arim_op ::= MINUS;

variable_def_part ::= VAR variable_def_list  ;
variable_def_list ::= variable_def_list variable_def;
variable_def_list ::= NEWLINE variable_def_list;
variable_def_list ::= variable_def;
variable_def ::= identifier_list COLON type_def SEMI;

attr ::= identifier assign_operator exp_part;
attr ::= identifier assign_operator error {: parser.report_error("Error in expression ", "ERROR"); :};

assign_operator ::= error {: parser.report_error("Expected symbol before = ", "ERROR"); :};

assign_operator ::= equal_op;
assign_operator ::= sum_op;
assign_operator ::= minus_op;
assign_operator ::= times_op;
assign_operator ::= divide_op; 

equal_op ::= COLON EQUAL;
sum_op  ::= PLUS EQUAL;
minus_op  ::= MINUS EQUAL;
times_op ::= TIMES EQUAL;
divide_op ::= DIVIDE EQUAL;

identifier_list ::= identifier_list COMMA identifier; 
identifier_list ::= identifier;

type_def ::= CHAR;
type_def ::= BOOL;
type_def ::= INT;

// ~~ CUP-ECLIPSE:CONFLICT-RES-RR ~~ 
 // After this the order of productions matters

//Separated and moved by CUP Eclipse plugin


//Moved by CUP Eclipse plugin


//Moved by CUP Eclipse plugin


//Moved by CUP Eclipse plugin
header_declarations ::= ;

//Moved by CUP Eclipse plugin
procedure_def_part ::= ;

//Moved by CUP Eclipse plugin
variable_def_part ::= ;

//Moved by CUP Eclipse plugin
function_def_part ::= ;
